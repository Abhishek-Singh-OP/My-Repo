# Define character mappings based on possible OCR misreadings
char_mapping = {
    'D': '[D0O]',
    'O': '[O0D]',
    '0': '[0OD]',
    'I': '[I1l|]',
    '1': '[1lI|]',
    '4': '[49]',
    '5': '[5S]',
    'S': '[S5]',
    '9': '[94]',
    '8': '[8B]',
    'B': '[B8]'
}

# Create the regex pattern for the DIN format with OCR misreading considerations
din_pattern = re.compile(
    rf'\b{char_mapping["D"]}{char_mapping["I"]}{char_mapping["N"]}\s*1418\s*[-= ]?\s*4\s*[-= ]?\s*H\s*[-= ]?\s*(1|[lI|]|2|3|4|5|6|8|10|16|20)\b',
    re.IGNORECASE
)






import json
import re
import requests

# Define API endpoint and API key if required
api_url = 'https://api.example.com/ocr'  # Replace with actual API URL
api_key = 'your_api_key_here'  # Replace with actual API key if needed

# Define regex patterns
din_pattern = re.compile(
    r'\bDIN\s+1418(?:\s*[-=]\s*4(?:\s*[-=]\s*H\s*)?)?\s*(?:[-=]\s*)?([1,6]|2|3|4|5|6|8|10|16|20)\b',
    re.IGNORECASE
)
iso_pattern = re.compile(r'\bISO\b', re.IGNORECASE)
mbn_pattern = re.compile(r'\bMBN\b', re.IGNORECASE)

# Function to check validity
def check_validity(text):
    has_din = din_pattern.search(text)
    has_iso = iso_pattern.search(text)
    has_mbn = mbn_pattern.search(text)
    
    # Check if text has DIN or ISO
    if has_din or has_iso:
        # Check if DIN or ISO is accompanied by MBN
        if has_mbn:
            return False  # Invalid if DIN or ISO is with MBN
        return True  # Valid if DIN or ISO is not with MBN
    return False  # Invalid if neither DIN nor ISO is present

# Function to get OCR results from API
def get_ocr_results(image_path):
    with open(image_path, 'rb') as image_file:
        files = {'image': image_file}
        headers = {'Authorization': f'Bearer {api_key}'}  # Add API key in headers if required
        response = requests.post(api_url, files=files, headers=headers)
        
        if response.status_code == 200:
            return response.json()  # Return the JSON response from the API
        else:
            response.raise_for_status()  # Raise an exception for HTTP errors

# Main processing function
def process_image(image_path):
    ocr_results = get_ocr_results(image_path)
    
    # Iterate through OCR results and validate
    detailed_results = []

    for result in ocr_results:
        if isinstance(result, list) and len(result) >= 1:
            for sublist in result:
                if isinstance(sublist, list) and len(sublist) >= 2:
                    text_data = sublist[1]  # Second element in the sublist
                    if isinstance(text_data, list) and len(text_data) >= 1:
                        text = text_data[0]  # The actual text
                        if isinstance(text, str):
                            is_valid = check_validity(text)
                            detailed_results.append({
                                'text': text,
                                'valid': is_valid
                            })

    # Output results
    valid_texts = [result for result in detailed_results if result['valid']]
    invalid_texts = [result for result in detailed_results if not result['valid']]

    print(f"Valid Results: {len(valid_texts)}")
    print(f"Invalid Results: {len(invalid_texts)}")

    # Save detailed results to JSON files
    with open('detailed_results.json', 'w') as file:
        json.dump(detailed_results, file, indent=2)

# Example usage
image_path = 'path_to_your_image.jpg'  # Replace with the path to your image file
process_image(image_path)






import re
import json
import requests

# Replace with your actual API URL for uploading images and getting OCR results
api_url = "http://53.217.48.242:8000/ocr/paddle"  # Update this with the correct endpoint

# Path to the image file you want to upload
image_path = "./label_1.png"

# Allowed set of numbers after DIN-1451-H
allowed_numbers = {'1,6', '2', '3', '4', '5', '6', '8', '10', '16', '20'}

# Threshold for vertical distance to consider lines as part of the same label
vertical_distance_threshold = 10  # Adjust based on your data

# Function to upload the image and get the response
def upload_image_and_get_text(api_url, image_path):
    try:
        with open(image_path, 'rb') as image_file:
            files = {'file': image_file}
            response = requests.post(api_url, files=files, timeout=30)

            # Debugging: Log the request details
            print(f"Request URL: {api_url}")
            print(f"Request Files: {files}")

            # Check if the request was successful
            if response.status_code == 200:
                # Parse the JSON response
                response_data = response.json()
                return response_data
            else:
                print(f"Failed to fetch data from API. Status code: {response.status_code}")
                print(f"Response Text: {response.text}")
                return None
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")
        return None

# Function to group lines based on vertical positioning
def group_lines_by_position(lines, threshold):
    grouped_lines = []
    current_group = [lines[0]]

    for i in range(1, len(lines)):
        current_line = lines[i]
        previous_line = lines[i - 1]

        # Calculate vertical distance
        vertical_distance = current_line['bbox'][1] - previous_line['bbox'][3]

        if vertical_distance < threshold:
            current_group.append(current_line)
        else:
            grouped_lines.append(current_group)
            current_group = [current_line]

    grouped_lines.append(current_group)
    return grouped_lines

# Function to concatenate grouped lines into single labels
def concatenate_grouped_lines(grouped_lines):
    concatenated_texts = []
    for group in grouped_lines:
        concatenated_text = " ".join([line['text'] for line in group])
        concatenated_texts.append(concatenated_text)
    return concatenated_texts

# Define the flexible DIN-1451-H pattern
din_pattern = re.compile(r'DIN[-–\s]?1451[-–\s]?H[=\s]?(\d+,\d+|\d+)')
iso_pattern = re.compile(r'ISO 3097-BVL')
mbn_pattern = re.compile(r'MBN')

# Function to validate the extracted text
def validate_texts(texts):
    for text in texts:
        contains_din = din_pattern.search(text)
        contains_iso = bool(iso_pattern.search(text))
        contains_mbn = bool(mbn_pattern.search(text))

        # Debug: print whether each pattern was found
        print(f"Text: {text}")
        print(f"Contains DIN-1451-H: {bool(contains_din)}")
        print(f"Contains ISO 3097-BVL: {contains_iso}")
        print(f"Contains MBN: {contains_mbn}")

        if contains_din:
            din_match = contains_din.group(1)
            # Check if the number is in the allowed set
            if din_match not in allowed_numbers:
                print(f"Validation Error: DIN-1451-H number not allowed: {din_match}")
            else:
                print(f"DIN-1451-H number format correct: {din_match}")

        if (contains_din or contains_iso) and contains_mbn:
            print(f"Validation Error: Text contains both DIN/ISO and MBN")
        else:
            print(f"Text is valid")

# Main function to execute the workflow
def main():
    response_data = upload_image_and_get_text(api_url, image_path)
    if response_data:
        lines = response_data[1]  # Adjust this based on the actual structure of your response
        grouped_lines = group_lines_by_position(lines, vertical_distance_threshold)
        concatenated_texts = concatenate_grouped_lines(grouped_lines)
        validate_texts(concatenated_texts)

if __name__ == "__main__":
    main()
