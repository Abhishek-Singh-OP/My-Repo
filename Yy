import re
import json
import requests

# Replace with your actual API URL for uploading images and getting OCR results
api_url = "http://53.217.48.242:8000/ocr/paddle"  # Update this with the correct endpoint

# Path to the image file you want to upload
image_path = "./label_1.png"

# Allowed set of numbers after DIN-1451-H
allowed_numbers = {'1,6', '2', '3', '4', '5', '6', '8', '10', '16', '20'}

# Threshold for vertical distance to consider lines as part of the same label
vertical_distance_threshold = 10  # Adjust based on your data

# Function to upload the image and get the response
def upload_image_and_get_text(api_url, image_path):
    try:
        with open(image_path, 'rb') as image_file:
            files = {'file': image_file}
            response = requests.post(api_url, files=files, timeout=30)

            # Debugging: Log the request details
            print(f"Request URL: {api_url}")
            print(f"Request Files: {files}")

            # Check if the request was successful
            if response.status_code == 200:
                # Parse the JSON response
                response_data = response.json()
                return response_data
            else:
                print(f"Failed to fetch data from API. Status code: {response.status_code}")
                print(f"Response Text: {response.text}")
                return None
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")
        return None

# Function to group lines based on vertical positioning
def group_lines_by_position(lines, threshold):
    grouped_lines = []
    current_group = [lines[0]]

    for i in range(1, len(lines)):
        current_line = lines[i]
        previous_line = lines[i - 1]

        # Calculate vertical distance
        vertical_distance = current_line['bbox'][1] - previous_line['bbox'][3]

        if vertical_distance < threshold:
            current_group.append(current_line)
        else:
            grouped_lines.append(current_group)
            current_group = [current_line]

    grouped_lines.append(current_group)
    return grouped_lines

# Function to concatenate grouped lines into single labels
def concatenate_grouped_lines(grouped_lines):
    concatenated_texts = []
    for group in grouped_lines:
        concatenated_text = " ".join([line['text'] for line in group])
        concatenated_texts.append(concatenated_text)
    return concatenated_texts

# Define the flexible DIN-1451-H pattern
din_pattern = re.compile(r'DIN[-–\s]?1451[-–\s]?H[=\s]?(\d+,\d+|\d+)')
iso_pattern = re.compile(r'ISO 3097-BVL')
mbn_pattern = re.compile(r'MBN')

# Function to validate the extracted text
def validate_texts(texts):
    for text in texts:
        contains_din = din_pattern.search(text)
        contains_iso = bool(iso_pattern.search(text))
        contains_mbn = bool(mbn_pattern.search(text))

        # Debug: print whether each pattern was found
        print(f"Text: {text}")
        print(f"Contains DIN-1451-H: {bool(contains_din)}")
        print(f"Contains ISO 3097-BVL: {contains_iso}")
        print(f"Contains MBN: {contains_mbn}")

        if contains_din:
            din_match = contains_din.group(1)
            # Check if the number is in the allowed set
            if din_match not in allowed_numbers:
                print(f"Validation Error: DIN-1451-H number not allowed: {din_match}")
            else:
                print(f"DIN-1451-H number format correct: {din_match}")

        if (contains_din or contains_iso) and contains_mbn:
            print(f"Validation Error: Text contains both DIN/ISO and MBN")
        else:
            print(f"Text is valid")

# Main function to execute the workflow
def main():
    response_data = upload_image_and_get_text(api_url, image_path)
    if response_data:
        lines = response_data[1]  # Adjust this based on the actual structure of your response
        grouped_lines = group_lines_by_position(lines, vertical_distance_threshold)
        concatenated_texts = concatenate_grouped_lines(grouped_lines)
        validate_texts(concatenated_texts)

if __name__ == "__main__":
    main()
