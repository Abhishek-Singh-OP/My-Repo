import json
import re

# Load the JSON file
with open('paddle_ocr_output.json', 'r') as file:
    ocr_results = json.load(file)

# Define regex patterns
din_pattern = re.compile(r'\bDIN\s+\d{4}-\d{1,2}-H\s*([1,6]|2|3|4|5|6|8|10|16|20)\b', re.IGNORECASE)
iso_pattern = re.compile(r'\bISO\b', re.IGNORECASE)
mbn_pattern = re.compile(r'\bMBN\b', re.IGNORECASE)

# Function to check validity
def check_validity(text):
    has_din = din_pattern.search(text)
    has_iso = iso_pattern.search(text)
    has_mbn = mbn_pattern.search(text)
    
    # Check if text has DIN or ISO
    if has_din or has_iso:
        # Check if DIN or ISO is accompanied by MBN
        if has_mbn:
            return False  # Invalid if DIN or ISO is with MBN
        return True  # Valid if DIN or ISO is not with MBN
    return False  # Invalid if neither DIN nor ISO is present

# Iterate through OCR results and validate
valid_results = []
invalid_results = []

for result in ocr_results:
    if isinstance(result, list):
        # Extract text from each sublist if it's in list format
        for item in result:
            if isinstance(item, str):  # Ensure the item is a string
                text = item
                if check_validity(text):
                    valid_results.append(result)
                    break  # Skip to next result if one valid text is found
        else:
            invalid_results.append(result)

# Output results
print(f"Valid Results: {len(valid_results)}")
print(f"Invalid Results: {len(invalid_results)}")

# Optionally, you can save the results to separate files
with open('valid_results.json', 'w') as file:
    json.dump(valid_results, file, indent=2)

with open('invalid_results.json', 'w') as file:
    json.dump(invalid_results, file, indent=2)









import json
import re

# Load the JSON file
with open('paddle_ocr_output.json', 'r') as file:
    ocr_results = json.load(file)

# Define regex patterns
din_pattern = re.compile(r'\bDIN\s+\d{4}-\d{1,2}-H\s*([1,6]|2|3|4|5|6|8|10|16|20)\b', re.IGNORECASE)
iso_pattern = re.compile(r'\bISO\b', re.IGNORECASE)
mbn_pattern = re.compile(r'\bMBN\b', re.IGNORECASE)

# Function to check validity
def check_validity(text):
    has_din = din_pattern.search(text)
    has_iso = iso_pattern.search(text)
    has_mbn = mbn_pattern.search(text)
    
    # Check if text has DIN or ISO
    if has_din or has_iso:
        # Check if DIN or ISO is accompanied by MBN
        if has_mbn:
            return False  # Invalid if DIN or ISO is with MBN
        return True  # Valid if DIN or ISO is not with MBN
    return False  # Invalid if neither DIN nor ISO is present

# Iterate through OCR results and validate
valid_results = []
invalid_results = []

for result in ocr_results:
    if isinstance(result, list) and result:
        text = result[0]  # Assuming text is the first element in the list
        if check_validity(text):
            valid_results.append(result)
        else:
            invalid_results.append(result)

# Output results
print(f"Valid Results: {len(valid_results)}")
print(f"Invalid Results: {len(invalid_results)}")

# Optionally, you can save the results to separate files
with open('valid_results.json', 'w') as file:
    json.dump(valid_results, file, indent=2)

with open('invalid_results.json', 'w') as file:
    json.dump(invalid_results, file, indent=2)








import json
import re

# Load the JSON file
with open('paddle_ocr_output.json', 'r') as file:
    ocr_results = json.load(file)

# Define regex patterns
din_pattern = re.compile(r'\bDIN\s+\d{4}-\d{1,2}-H\s*([1,6]|2|3|4|5|6|8|10|16|20)\b', re.IGNORECASE)
iso_pattern = re.compile(r'\bISO\b', re.IGNORECASE)
mbn_pattern = re.compile(r'\bMBN\b', re.IGNORECASE)

# Function to check validity
def check_validity(text):
    has_din = din_pattern.search(text)
    has_iso = iso_pattern.search(text)
    has_mbn = mbn_pattern.search(text)
    
    # Check if text has DIN or ISO
    if has_din or has_iso:
        # Check if DIN or ISO is accompanied by MBN
        if has_mbn:
            return False  # Invalid if DIN or ISO is with MBN
        return True  # Valid if DIN or ISO is not with MBN
    return False  # Invalid if neither DIN nor ISO is present

# Iterate through OCR results and validate
valid_results = []
invalid_results = []

for result in ocr_results:
    text = result.get('text', '')
    if check_validity(text):
        valid_results.append(result)
    else:
        invalid_results.append(result)

# Output results
print(f"Valid Results: {len(valid_results)}")
print(f"Invalid Results: {len(invalid_results)}")

# Optionally, you can save the results to separate files
with open('valid_results.json', 'w') as file:
    json.dump(valid_results, file, indent=2)

with open('invalid_results.json', 'w') as file:
    json.dump(invalid_results, file, indent=2)






import json
import re

# Define regex patterns
patterns = {
    'DIN': r'\bDIN \d{4}-\d{2}\b',
    'ISO': r'\bISO \d{4}(-\d{2})?\b',
    'MBN': r'\bMBN \d{5}\b'
}

# Load JSON data
with open('your_file.json', 'r') as file:
    data = json.load(file)

def extract_and_match_text(data):
    # Flatten the nested lists
    def flatten(lst):
        while isinstance(lst[0], list):
            lst = lst[0]
        return lst
    
    for item in data:
        if isinstance(item, list):
            item = flatten(item)
            if len(item) >= 2:
                coordinates = item[0]
                text_data = item[1]
                if isinstance(text_data, list) and len(text_data) >= 2:
                    text, _ = text_data
                    # Check each pattern
                    for key, pattern in patterns.items():
                        matches = re.findall(pattern, text)
                        if matches:
                            print(f"Pattern '{key}' found in text: {text}")
                            for match in matches:
                                print(f"  Match: {match}")

# Call the function with your data
extract_and_match_text(data)









import json
import re

# Define regex patterns
patterns = {
    'DIN': r'\bDIN \d{4}-\d{2}\b',
    'ISO': r'\bISO \d{4}(-\d{2})?\b',
    'MBN': r'\bMBN \d{5}\b'
}

# Load JSON data
with open('your_file.json', 'r') as file:
    data = json.load(file)

def extract_and_match_text(data):
    for item in data:
        if isinstance(item, list):
            # Assuming the structure is [coordinates, [text, difficulty]]
            coordinates, text_data = item
            if isinstance(text_data, list):
                text, _ = text_data
                # Check each pattern
                for key, pattern in patterns.items():
                    matches = re.findall(pattern, text)
                    if matches:
                        print(f"Pattern '{key}' found in text: {text}")
                        for match in matches:
                            print(f"  Match: {match}")

# Call the function with your data
extract_and_match_text(data)








import json
import re

def identify_pattern(json_file, din_numbers, iso_pattern="ISO 3097-BVL", mbن_number="MBN 50435"):
  """
  This function reads a JSON file containing OCR results and identifies patterns based on DIN, ISO, and MBN keywords.

  Args:
    json_file: Path to the JSON file.
    din_numbers: List of DIN numbers to match.
    iso_pattern: Regex pattern for ISO keyword.
    mbn_number: MBN number to match.

  Returns:
    A list of lines that match the specified pattern.
  """

  with open(json_file, 'r') as f:
    data = json.load(f)

  # Extract text and confidence scores from the JSON data
  lines = []
  for line in data:
    text = line[0]
    confidence = line[1]
    lines.append((text, confidence))

  # Define regular expressions for matching DIN, ISO, and MBN patterns
  din_regex = r"DIN 1418-4-H(?P<number>\d+)"
  mbn_regex = rf"{mbن_number}"

  matching_lines = []
  for text, confidence in lines:
    # Check for DIN pattern
    din_match = re.search(din_regex, text)
    if din_match and din_match.group('number') in din_numbers:
      matching_lines.append(text)
      continue

    # Check for ISO pattern
    if re.search(iso_pattern, text):
      matching_lines.append(text)

  # Check for invalid cases (both DIN/ISO and MBN present)
  invalid_lines = [line for line in matching_lines if re.search(mbn_regex, line)]

  return invalid_lines

# Example usage
din_numbers = ["1234", "5678"]
invalid_lines = identify_pattern("ocr_results.json", din_numbers)

if invalid_lines:
  print("Invalid lines:")
  for line in invalid_lines:
    print(line)
else:
  print("No invalid lines found")







import json
import re

# Allowed set of numbers after DIN-1451-H
allowed_numbers = {'1,6', '2', '3', '4', '5', '6', '8', '10', '16', '20'}

# Threshold for vertical distance to consider lines as part of the same label
vertical_distance_threshold = 10  # Adjust based on your data

# Function to read JSON data from a file
def read_json_file(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
    return data

# Function to group lines based on vertical positioning
def group_lines_by_position(lines, threshold):
    grouped_lines = []
    current_group = [lines[0]]

    for i in range(1, len(lines)):
        current_line = lines[i]
        previous_line = lines[i - 1]

        # Calculate vertical distance
        vertical_distance = current_line['bbox'][1] - previous_line['bbox'][3]

        if vertical_distance < threshold:
            current_group.append(current_line)
        else:
            grouped_lines.append(current_group)
            current_group = [current_line]

    grouped_lines.append(current_group)
    return grouped_lines

# Function to concatenate grouped lines into single strings
def concatenate_grouped_lines(grouped_lines):
    concatenated_texts = []
    for group in grouped_lines:
        concatenated_text = ' '.join([line['text'] for line in group])
        concatenated_texts.append(concatenated_text)
    return concatenated_texts

# Function to validate extracted texts
def validate_texts(concatenated_texts):
    for text in concatenated_texts:
        match = re.search(r'DIN-1451-H\s*(\d+,\d+|\d+)', text)
        if match:
            number = match.group(1)
            if number in allowed_numbers:
                print(f"Valid number found: {number} in text: {text}")
            else:
                print(f"Invalid number found: {number} in text: {text}")
        else:
            print(f"No valid pattern found in text: {text}")

def main():
    file_path = 'path_to_your_json_file.json'
    response_data = read_json_file(file_path)

    # Ensure response_data is correctly formatted
    if isinstance(response_data, list) and all(isinstance(item, list) and len(item) == 3 for item in response_data):
        # Transform the response data to the required format
        lines = [{'text': item[1], 'bbox': item[0]} for item in response_data]
    else:
        print("Unexpected item format:", response_data)
        return

    lines.sort(key=lambda x: x['bbox'][1])  # Sort by the top y-coordinate

    # Debug print to check the sorted lines
    print("Sorted Lines:", lines)

    # Group lines by position
    grouped_lines = group_lines_by_position(lines, vertical_distance_threshold)

    # Debug print to check the structure of grouped_lines
    print("Grouped Lines:", grouped_lines)

    # Concatenate grouped lines
    concatenated_texts = concatenate_grouped_lines(grouped_lines)

    # Debug print to check the concatenated texts
    print("Concatenated Texts:", concatenated_texts)

    # Validate texts
    validate_texts(concatenated_texts)

if __name__ == "__main__":
    main()








import json
import re

# Allowed set of numbers after DIN-1451-H
allowed_numbers = {'1,6', '2', '3', '4', '5', '6', '8', '10', '16', '20'}

# Threshold for vertical distance to consider lines as part of the same label
vertical_distance_threshold = 10  # Adjust based on your data

# Function to read JSON data from a file
def read_json_file(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
    return data

# Function to group lines based on vertical positioning
def group_lines_by_position(lines, threshold):
    grouped_lines = []
    current_group = [lines[0]]

    for i in range(1, len(lines)):
        current_line = lines[i]
        previous_line = lines[i - 1]

        # Calculate vertical distance
        vertical_distance = current_line['bbox'][1] - previous_line['bbox'][3]

        if vertical_distance < threshold:
            current_group.append(current_line)
        else:
            grouped_lines.append(current_group)
            current_group = [current_line]

    grouped_lines.append(current_group)
    return grouped_lines

# Function to concatenate grouped lines into single strings
def concatenate_grouped_lines(grouped_lines):
    concatenated_texts = []
    for group in grouped_lines:
        concatenated_text = ' '.join([line['text'] for line in group])
        concatenated_texts.append(concatenated_text)
    return concatenated_texts

# Function to validate extracted texts
def validate_texts(concatenated_texts):
    for text in concatenated_texts:
        match = re.search(r'DIN-1451-H\s*(\d+,\d+|\d+)', text)
        if match:
            number = match.group(1)
            if number in allowed_numbers:
                print(f"Valid number found: {number} in text: {text}")
            else:
                print(f"Invalid number found: {number} in text: {text}")
        else:
            print(f"No valid pattern found in text: {text}")

def main():
    file_path = 'path_to_your_json_file.json'
    response_data = read_json_file(file_path)

    # Ensure response_data is correctly formatted
    if isinstance(response_data, list) and all(isinstance(item, list) and len(item) == 4 for item in response_data):
        # Transform the response data to the required format
        lines = [{'text': item[1], 'bbox': item[0]} for item in response_data]
    else:
        print("Unexpected item format:", response_data)
        return

    lines.sort(key=lambda x: x['bbox'][1])  # Sort by the top y-coordinate

    # Group lines by position
    grouped_lines = group_lines_by_position(lines, vertical_distance_threshold)

    # Debug print to check the structure of grouped_lines
    print("Grouped Lines:", grouped_lines)

    # Concatenate grouped lines
    concatenated_texts = concatenate_grouped_lines(grouped_lines)

    # Validate texts
    validate_texts(concatenated_texts)

if __name__ == "__main__":
    main()
